// Copyright (c) 2024, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:dartdoc_vitepress/src/generator/vitepress_paths.dart';
import 'package:dartdoc_vitepress/src/model/model.dart';

/// Generates the `.vitepress/generated/api-sidebar.ts` TypeScript file that
/// VitePress uses for sidebar navigation.
///
/// Traverses the [PackageGraph] model to produce a structured sidebar with:
/// - Library-level groups with `base` path deduplication
/// - Kind sub-groups (Classes, Exceptions, Enums, etc.)
/// - Category-based sub-grouping when >=2 categories exist in a kind group
/// - Adaptive collapse thresholds
/// - Multi-package nesting when multiple local packages exist
/// - Path-based routing for large projects (>100 total elements)
class VitePressSidebarGenerator {
  final VitePressPathResolver paths;

  VitePressSidebarGenerator(this.paths);

  /// Generates the full contents of `api-sidebar.ts`.
  String generate(PackageGraph packageGraph) {
    final localPackages = packageGraph.localPackages;
    final isMultiPackage = localPackages.length > 1;

    // Count total elements across all libraries.
    var totalElements = 0;
    for (final package in localPackages) {
      for (final library in package.publicLibrariesSorted) {
        totalElements += _countLibraryElements(library);
      }
    }

    final usePathRouting = totalElements > 100;
    final buf = StringBuffer();

    buf.writeln(
      '// AUTO-GENERATED by dartdoc-vitepress -- do not edit manually.',
    );
    buf.writeln("import type { DefaultTheme } from 'vitepress'");
    buf.writeln();

    if (usePathRouting) {
      _generatePathBased(buf, localPackages, isMultiPackage);
    } else {
      _generateFlat(buf, localPackages, isMultiPackage);
    }

    return buf.toString();
  }

  /// Generates a flat `SidebarItem[]` export for smaller projects.
  ///
  /// Wraps the result in a `DefaultTheme.Sidebar` record with an `/api/` key
  /// so the config.ts can always use `sidebar: apiSidebar` directly.
  void _generateFlat(
    StringBuffer buf,
    List<Package> packages,
    bool isMultiPackage,
  ) {
    buf.writeln(
      'export const apiSidebar: DefaultTheme.Sidebar = {',
    );
    buf.writeln("  '/api/': [");

    for (final package in packages) {
      final libraries = package.publicLibrariesSorted;
      if (libraries.isEmpty) continue;

      final categories = _sortedCategoriesWithLibraries(package);

      if (isMultiPackage) {
        // When the package has a single library with the same name,
        // skip the package-level wrapper to avoid redundant nesting.
        if (libraries.length == 1 && libraries.first.name == package.name) {
          _writeLibraryGroup(buf, libraries.first, indent: 4);
        } else if (categories.isNotEmpty) {
          // Package has categories — group libraries by category inside
          // a package-level wrapper.
          buf.writeln('    {');
          buf.writeln("      text: '${_escapeTs(package.name)}',");
          buf.writeln('      collapsed: false,');
          buf.writeln('      items: [');
          _writeCategoryGroups(
            buf, package, categories, libraries,
            indent: 8, writeLibraryGroups: true,
          );
          buf.writeln('      ],');
          buf.writeln('    },');
        } else {
          // No categories — flat list with sameNameLib dedup.
          final sameNameLib = libraries
              .where((l) => l.name == package.name)
              .firstOrNull;
          final otherLibs = sameNameLib != null
              ? libraries.where((l) => l.name != package.name).toList()
              : libraries;

          buf.writeln('    {');
          buf.writeln("      text: '${_escapeTs(package.name)}',");
          if (sameNameLib != null) {
            final dirName = paths.dirNameFor(sameNameLib);
            buf.writeln("      link: '/api/$dirName/',");
          }
          buf.writeln('      collapsed: false,');
          buf.writeln('      items: [');
          for (final library in otherLibs) {
            _writeLibraryGroup(buf, library, indent: 8);
          }
          buf.writeln('      ],');
          buf.writeln('    },');
        }
      } else if (categories.isNotEmpty) {
        // Single package with categories — categories at top level.
        _writeCategoryGroups(
          buf, package, categories, libraries,
          indent: 4, writeLibraryGroups: true,
        );
      } else {
        for (final library in libraries) {
          _writeLibraryGroup(buf, library, indent: 4);
        }
      }
    }

    buf.writeln('  ],');
    buf.writeln('}');
  }

  /// Generates a `Record<string, SidebarItem[]>` export for large projects
  /// with path-based sidebar routing.
  void _generatePathBased(
    StringBuffer buf,
    List<Package> packages,
    bool isMultiPackage,
  ) {
    buf.writeln(
      'export const apiSidebar: DefaultTheme.Sidebar = {',
    );

    for (final package in packages) {
      for (final library in package.publicLibrariesSorted) {
        final dirName = paths.dirNameFor(library);
        final base = '/api/$dirName/';
        buf.writeln("  '${_escapeTs(base)}': [");
        _writeLibraryGroup(buf, library, indent: 4, forceExpand: true);
        buf.writeln('  ],');
      }
    }

    // Fallback overview sidebar for /api/.
    buf.writeln("  '/api/': [");
    for (final package in packages) {
      final libraries = package.publicLibrariesSorted;
      if (libraries.isEmpty) continue;

      final categories = _sortedCategoriesWithLibraries(package);

      if (isMultiPackage) {
        if (libraries.length == 1 && libraries.first.name == package.name) {
          // Single library matching package name — no wrapper needed.
          final dirName = paths.dirNameFor(libraries.first);
          buf.writeln('    {');
          buf.writeln("      text: '${_escapeTs(libraries.first.name)}',");
          buf.writeln("      link: '/api/$dirName/',");
          buf.writeln('    },');
        } else if (categories.isNotEmpty) {
          // Package with categories — group by category inside package.
          buf.writeln('    {');
          buf.writeln("      text: '${_escapeTs(package.name)}',");
          buf.writeln('      items: [');
          _writeCategoryGroups(
            buf, package, categories, libraries,
            indent: 8, writeLibraryGroups: false,
          );
          buf.writeln('      ],');
          buf.writeln('    },');
        } else {
          // No categories — flat list with sameNameLib dedup.
          final sameNameLib = libraries
              .where((l) => l.name == package.name)
              .firstOrNull;
          final otherLibs = sameNameLib != null
              ? libraries.where((l) => l.name != package.name).toList()
              : libraries;

          buf.writeln('    {');
          buf.writeln("      text: '${_escapeTs(package.name)}',");
          if (sameNameLib != null) {
            final dirName = paths.dirNameFor(sameNameLib);
            buf.writeln("      link: '/api/$dirName/',");
          }
          buf.writeln('      items: [');
          for (final library in otherLibs) {
            final dirName = paths.dirNameFor(library);
            buf.writeln('        {');
            buf.writeln("          text: '${_escapeTs(library.name)}',");
            buf.writeln("          link: '/api/$dirName/',");
            buf.writeln('        },');
          }
          buf.writeln('      ],');
          buf.writeln('    },');
        }
      } else if (categories.isNotEmpty) {
        // Single package with categories — categories at top level.
        _writeCategoryGroups(
          buf, package, categories, libraries,
          indent: 4, writeLibraryGroups: false,
        );
      } else {
        for (final library in libraries) {
          final dirName = paths.dirNameFor(library);
          buf.writeln('    {');
          buf.writeln("      text: '${_escapeTs(library.name)}',");
          buf.writeln("      link: '/api/$dirName/',");
          buf.writeln('    },');
        }
      }
    }
    buf.writeln('  ],');

    buf.writeln('}');
  }

  /// Writes library groups organized by category.
  ///
  /// Each category becomes a collapsible group containing its libraries.
  /// When [writeLibraryGroups] is true, libraries are rendered as full groups
  /// (with Overview, Classes, etc.); when false, as simple links.
  ///
  /// Libraries not in any category are placed in an "Other" group at the end.
  /// External items (like `package:web` in the SDK) are included in their
  /// respective category groups.
  void _writeCategoryGroups(
    StringBuffer buf,
    Package package,
    List<Category> categories,
    List<Library> allLibraries, {
    required int indent,
    required bool writeLibraryGroups,
  }) {
    final pad = ' ' * indent;

    // Collect all categorized libraries to find uncategorized ones later.
    final categorizedLibs = <Library>{};

    for (final category in categories) {
      // Only include libraries with actual API elements (classes, functions,
      // etc.) — skip stub/overview-only libraries.
      final libs = category.publicLibrariesSorted
          .where((l) => _countLibraryElements(l) > 0)
          .toList();
      categorizedLibs.addAll(category.publicLibrariesSorted);

      // Skip empty categories with no external items.
      if (libs.isEmpty && category.externalItems.isEmpty) continue;

      buf.writeln('$pad{');
      buf.writeln("$pad  text: '${_escapeTs(category.name)}',");
      buf.writeln('$pad  collapsed: false,');
      buf.writeln('$pad  items: [');

      // External items first (e.g. package:web link).
      for (final ext in category.externalItems) {
        buf.writeln('$pad    {');
        buf.writeln("$pad      text: '${_escapeTs(ext.name)}',");
        buf.writeln("$pad      link: '${_escapeTs(ext.url)}',");
        buf.writeln('$pad    },');
      }

      for (final lib in libs) {
        if (writeLibraryGroups) {
          _writeLibraryGroup(buf, lib, indent: indent + 4);
        } else {
          final dirName = paths.dirNameFor(lib);
          buf.writeln('$pad    {');
          buf.writeln("$pad      text: '${_escapeTs(lib.name)}',");
          buf.writeln("$pad      link: '/api/$dirName/',");
          buf.writeln('$pad    },');
        }
      }

      buf.writeln('$pad  ],');
      buf.writeln('$pad},');
    }

    // Libraries not in any category.
    final uncategorized = allLibraries
        .where((l) => !categorizedLibs.contains(l))
        .toList();

    if (uncategorized.isNotEmpty) {
      buf.writeln('$pad{');
      buf.writeln("$pad  text: 'Other',");
      buf.writeln('$pad  collapsed: false,');
      buf.writeln('$pad  items: [');
      for (final lib in uncategorized) {
        if (writeLibraryGroups) {
          _writeLibraryGroup(buf, lib, indent: indent + 4);
        } else {
          final dirName = paths.dirNameFor(lib);
          buf.writeln('$pad    {');
          buf.writeln("$pad      text: '${_escapeTs(lib.name)}',");
          buf.writeln("$pad      link: '/api/$dirName/',");
          buf.writeln('$pad    },');
        }
      }
      buf.writeln('$pad  ],');
      buf.writeln('$pad},');
    }
  }

  /// Writes a single library sidebar group with `base` path deduplication.
  ///
  /// When [forceExpand] is true the root group is never collapsed — used in
  /// path-based routing where the user already navigated to this library.
  void _writeLibraryGroup(
    StringBuffer buf,
    Library library, {
    required int indent,
    bool forceExpand = false,
  }) {
    final pad = ' ' * indent;
    final totalElements = _countLibraryElements(library);
    final libraryCollapsed = !forceExpand && totalElements > 30;
    final dirName = paths.dirNameFor(library);
    final base = '/api/$dirName/';

    buf.writeln('$pad{');
    buf.writeln("$pad  text: '${_escapeTs(library.name)}',");
    buf.writeln("$pad  base: '${_escapeTs(base)}',");
    buf.writeln('$pad  collapsed: $libraryCollapsed,');
    buf.writeln('$pad  items: [');

    // Overview link (relative to base).
    buf.writeln("$pad    { text: 'Overview', link: 'index.md' },");

    // Kind groups in the specified order.
    _writeKindGroup(
      buf,
      library,
      'Classes',
      library.publicClassesSorted,
      indent: indent + 4,
      collapseThreshold: 8,
      forceExpand: forceExpand,
    );
    _writeKindGroup(
      buf,
      library,
      'Exceptions',
      library.publicExceptionsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
      forceExpand: forceExpand,
    );
    _writeKindGroup(
      buf,
      library,
      'Enums',
      library.publicEnumsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
      forceExpand: forceExpand,
    );
    _writeKindGroup(
      buf,
      library,
      'Mixins',
      library.publicMixinsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
      forceExpand: forceExpand,
    );
    _writeKindGroup(
      buf,
      library,
      'Extensions',
      library.publicExtensionsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
      forceExpand: forceExpand,
    );
    _writeKindGroup(
      buf,
      library,
      'Extension Types',
      library.publicExtensionTypesSorted,
      indent: indent + 4,
      collapseThreshold: 8,
      forceExpand: forceExpand,
    );
    _writeKindGroup(
      buf,
      library,
      'Functions',
      library.publicFunctionsSorted,
      indent: indent + 4,
      collapseThreshold: 10,
      forceExpand: forceExpand,
    );
    _writeKindGroup(
      buf,
      library,
      'Properties',
      library.publicPropertiesSorted,
      indent: indent + 4,
      collapseThreshold: 10,
      forceExpand: forceExpand,
    );
    _writeKindGroup(
      buf,
      library,
      'Constants',
      library.publicConstantsSorted,
      indent: indent + 4,
      collapseThreshold: 10,
      forceExpand: forceExpand,
    );
    _writeKindGroup(
      buf,
      library,
      'Typedefs',
      library.publicTypedefsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
      forceExpand: forceExpand,
    );

    buf.writeln('$pad  ],');
    buf.writeln('$pad},');
  }

  /// Writes a kind group (e.g. "Classes") with optional category sub-grouping.
  ///
  /// Empty groups are omitted. If >=2 distinct categories exist among the
  /// elements, they are sub-grouped by category name. Uncategorized elements
  /// appear in an "Other" sub-group at the end.
  void _writeKindGroup(
    StringBuffer buf,
    Library library,
    String kindName,
    List<ModelElement> elements, {
    required int indent,
    required int collapseThreshold,
    bool forceExpand = false,
  }) {
    // Filter out re-exported elements — only show elements that belong to
    // this library (canonical library matches, or own library for unresolved).
    final filtered = elements
        .where((e) => _belongsToLibrary(e, library))
        .toList();
    if (filtered.isEmpty) return;

    final pad = ' ' * indent;
    final collapsed = !forceExpand && filtered.length > collapseThreshold;

    // Determine category distribution for sub-grouping.
    final categoryMap = <String, List<ModelElement>>{};
    final uncategorized = <ModelElement>[];

    for (final element in filtered) {
      final categories = element.displayedCategories.toList();
      if (categories.isEmpty) {
        uncategorized.add(element);
      } else {
        // Use the first category for grouping.
        final categoryName = categories.first.name;
        categoryMap.putIfAbsent(categoryName, () => []).add(element);
      }
    }

    // Only sub-group when >=2 distinct categories exist.
    final distinctCategories = categoryMap.keys.toList()..sort();
    final useCategoryGrouping = distinctCategories.length >= 2;

    buf.writeln('$pad{');
    buf.writeln("$pad  text: '${_escapeTs(kindName)}',");
    buf.writeln('$pad  collapsed: $collapsed,');
    buf.writeln('$pad  items: [');

    if (useCategoryGrouping) {
      // Write category sub-groups.
      for (final categoryName in distinctCategories) {
        final categoryElements = categoryMap[categoryName]!;
        buf.writeln('$pad    {');
        buf.writeln("$pad      text: '${_escapeTs(categoryName)}',");
        buf.writeln('$pad      collapsed: false,');
        buf.writeln('$pad      items: [');
        for (final element in categoryElements) {
          _writeElementItem(buf, element, library, indent: indent + 8);
        }
        buf.writeln('$pad      ],');
        buf.writeln('$pad    },');
      }
      // Write uncategorized elements in "Other" sub-group.
      if (uncategorized.isNotEmpty) {
        buf.writeln('$pad    {');
        buf.writeln("$pad      text: 'Other',");
        buf.writeln('$pad      collapsed: false,');
        buf.writeln('$pad      items: [');
        for (final element in uncategorized) {
          _writeElementItem(buf, element, library, indent: indent + 8);
        }
        buf.writeln('$pad      ],');
        buf.writeln('$pad    },');
      }
    } else {
      // Flat list without category sub-grouping.
      for (final element in filtered) {
        _writeElementItem(buf, element, library, indent: indent + 4);
      }
    }

    buf.writeln('$pad  ],');
    buf.writeln('$pad},');
  }

  /// Writes a single element sidebar item.
  ///
  /// Links are relative to the library's `base` path, so for an element
  /// at `/api/my_lib/MyClass` with base `/api/my_lib/`, the link is
  /// `/MyClass`.
  void _writeElementItem(
    StringBuffer buf,
    ModelElement element,
    Library library, {
    required int indent,
  }) {
    final url = paths.urlFor(element);
    if (url == null) return; // Skip elements without a generated page.

    final pad = ' ' * indent;
    final dirName = paths.dirNameFor(library);
    final base = '/api/$dirName/';

    // Make link relative to the library base.
    String link;
    if (url.startsWith(base)) {
      link = url.substring(base.length);
    } else if (url.startsWith('/api/')) {
      // Cross-package: relative to current library base.
      link = '../${url.substring('/api/'.length)}';
    } else {
      // Fallback: use as-is.
      link = url;
    }

    buf.writeln(
      "$pad{ text: '${_escapeTs(element.name)}', link: '${_escapeTs(link)}' },",
    );
  }

  /// Whether [element] belongs to [library]'s sidebar (not a re-export).
  static bool _belongsToLibrary(ModelElement e, Library library) {
    final canonical = e.canonicalLibrary;
    if (canonical == null) {
      // No canonical library — only show in the element's own library.
      return e.library == library;
    }
    return canonical == library;
  }

  /// Counts the total number of documented public elements in a library,
  /// excluding re-exported elements that belong to other libraries.
  int _countLibraryElements(Library library) {
    int count(List<ModelElement> elements) =>
        elements.where((e) => _belongsToLibrary(e, library)).length;
    return count(library.publicClassesSorted) +
        count(library.publicExceptionsSorted) +
        count(library.publicEnumsSorted) +
        count(library.publicMixinsSorted) +
        count(library.publicExtensionsSorted) +
        count(library.publicExtensionTypesSorted) +
        count(library.publicFunctionsSorted) +
        count(library.publicPropertiesSorted) +
        count(library.publicConstantsSorted) +
        count(library.publicTypedefsSorted);
  }

  /// Returns categories that have public libraries, sorted by the
  /// `categoryOrder` config option (same logic as `documentedCategoriesSorted`
  /// but without requiring a documentation markdown file).
  static List<Category> _sortedCategoriesWithLibraries(Package package) {
    final cats = package.categoriesWithPublicLibraries.toList();
    if (cats.isEmpty) return cats;

    final order = package.config.categoryOrder;
    if (order.isNotEmpty) {
      cats.sort((a, b) {
        final aIndex = order.indexOf(a.name);
        final bIndex = order.indexOf(b.name);
        if (aIndex >= 0 && bIndex >= 0) {
          return aIndex.compareTo(bIndex);
        } else if (aIndex < 0 && bIndex >= 0) {
          return 1;
        } else if (bIndex < 0 && aIndex >= 0) {
          return -1;
        } else {
          return a.name.compareTo(b.name);
        }
      });
    }
    return cats;
  }

  static String _escapeTs(String value) => escapeForTs(value);
}

/// Escapes a string for use inside a TypeScript single-quoted string.
///
/// Shared by [VitePressSidebarGenerator] and [VitePressGuideGenerator].
String escapeForTs(String value) {
  return value
      .replaceAll(r'\', r'\\')
      .replaceAll("'", r"\'")
      .replaceAll('\n', r'\n')
      .replaceAll('\r', r'\r')
      .replaceAll('\t', r'\t');
}
